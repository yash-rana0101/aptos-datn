"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@szmarczak";
exports.ids = ["vendor-chunks/@szmarczak"];
exports.modules = {

/***/ "(ssr)/./node_modules/@szmarczak/http-timer/dist/source/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@szmarczak/http-timer/dist/source/index.js ***!
  \*****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst defer_to_connect_1 = __webpack_require__(/*! defer-to-connect */ \"(ssr)/./node_modules/defer-to-connect/dist/source/index.js\");\nconst util_1 = __webpack_require__(/*! util */ \"util\");\nconst nodejsMajorVersion = Number(process.versions.node.split('.')[0]);\nconst timer = (request) => {\n    if (request.timings) {\n        return request.timings;\n    }\n    const timings = {\n        start: Date.now(),\n        socket: undefined,\n        lookup: undefined,\n        connect: undefined,\n        secureConnect: undefined,\n        upload: undefined,\n        response: undefined,\n        end: undefined,\n        error: undefined,\n        abort: undefined,\n        phases: {\n            wait: undefined,\n            dns: undefined,\n            tcp: undefined,\n            tls: undefined,\n            request: undefined,\n            firstByte: undefined,\n            download: undefined,\n            total: undefined\n        }\n    };\n    request.timings = timings;\n    const handleError = (origin) => {\n        const emit = origin.emit.bind(origin);\n        origin.emit = (event, ...args) => {\n            // Catches the `error` event\n            if (event === 'error') {\n                timings.error = Date.now();\n                timings.phases.total = timings.error - timings.start;\n                origin.emit = emit;\n            }\n            // Saves the original behavior\n            return emit(event, ...args);\n        };\n    };\n    handleError(request);\n    const onAbort = () => {\n        timings.abort = Date.now();\n        // Let the `end` response event be responsible for setting the total phase,\n        // unless the Node.js major version is >= 13.\n        if (!timings.response || nodejsMajorVersion >= 13) {\n            timings.phases.total = Date.now() - timings.start;\n        }\n    };\n    request.prependOnceListener('abort', onAbort);\n    const onSocket = (socket) => {\n        timings.socket = Date.now();\n        timings.phases.wait = timings.socket - timings.start;\n        if (util_1.types.isProxy(socket)) {\n            return;\n        }\n        const lookupListener = () => {\n            timings.lookup = Date.now();\n            timings.phases.dns = timings.lookup - timings.socket;\n        };\n        socket.prependOnceListener('lookup', lookupListener);\n        defer_to_connect_1.default(socket, {\n            connect: () => {\n                timings.connect = Date.now();\n                if (timings.lookup === undefined) {\n                    socket.removeListener('lookup', lookupListener);\n                    timings.lookup = timings.connect;\n                    timings.phases.dns = timings.lookup - timings.socket;\n                }\n                timings.phases.tcp = timings.connect - timings.lookup;\n                // This callback is called before flushing any data,\n                // so we don't need to set `timings.phases.request` here.\n            },\n            secureConnect: () => {\n                timings.secureConnect = Date.now();\n                timings.phases.tls = timings.secureConnect - timings.connect;\n            }\n        });\n    };\n    if (request.socket) {\n        onSocket(request.socket);\n    }\n    else {\n        request.prependOnceListener('socket', onSocket);\n    }\n    const onUpload = () => {\n        var _a;\n        timings.upload = Date.now();\n        timings.phases.request = timings.upload - ((_a = timings.secureConnect) !== null && _a !== void 0 ? _a : timings.connect);\n    };\n    const writableFinished = () => {\n        if (typeof request.writableFinished === 'boolean') {\n            return request.writableFinished;\n        }\n        // Node.js doesn't have `request.writableFinished` property\n        return request.finished && request.outputSize === 0 && (!request.socket || request.socket.writableLength === 0);\n    };\n    if (writableFinished()) {\n        onUpload();\n    }\n    else {\n        request.prependOnceListener('finish', onUpload);\n    }\n    request.prependOnceListener('response', (response) => {\n        timings.response = Date.now();\n        timings.phases.firstByte = timings.response - timings.upload;\n        response.timings = timings;\n        handleError(response);\n        response.prependOnceListener('end', () => {\n            timings.end = Date.now();\n            timings.phases.download = timings.end - timings.response;\n            timings.phases.total = timings.end - timings.start;\n        });\n        response.prependOnceListener('aborted', onAbort);\n    });\n    return timings;\n};\nexports[\"default\"] = timer;\n// For CommonJS default export support\nmodule.exports = timer;\nmodule.exports[\"default\"] = timer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN6bWFyY3phay9odHRwLXRpbWVyL2Rpc3Qvc291cmNlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQixtQkFBTyxDQUFDLG9GQUFrQjtBQUNyRCxlQUFlLG1CQUFPLENBQUMsa0JBQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBLHlCQUFzQiIsInNvdXJjZXMiOlsid2VicGFjazovL2N1c3RvbS1pbmRleGVyLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bzem1hcmN6YWsvaHR0cC10aW1lci9kaXN0L3NvdXJjZS9pbmRleC5qcz9kM2E4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZGVmZXJfdG9fY29ubmVjdF8xID0gcmVxdWlyZShcImRlZmVyLXRvLWNvbm5lY3RcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwidXRpbFwiKTtcbmNvbnN0IG5vZGVqc01ham9yVmVyc2lvbiA9IE51bWJlcihwcm9jZXNzLnZlcnNpb25zLm5vZGUuc3BsaXQoJy4nKVswXSk7XG5jb25zdCB0aW1lciA9IChyZXF1ZXN0KSA9PiB7XG4gICAgaWYgKHJlcXVlc3QudGltaW5ncykge1xuICAgICAgICByZXR1cm4gcmVxdWVzdC50aW1pbmdzO1xuICAgIH1cbiAgICBjb25zdCB0aW1pbmdzID0ge1xuICAgICAgICBzdGFydDogRGF0ZS5ub3coKSxcbiAgICAgICAgc29ja2V0OiB1bmRlZmluZWQsXG4gICAgICAgIGxvb2t1cDogdW5kZWZpbmVkLFxuICAgICAgICBjb25uZWN0OiB1bmRlZmluZWQsXG4gICAgICAgIHNlY3VyZUNvbm5lY3Q6IHVuZGVmaW5lZCxcbiAgICAgICAgdXBsb2FkOiB1bmRlZmluZWQsXG4gICAgICAgIHJlc3BvbnNlOiB1bmRlZmluZWQsXG4gICAgICAgIGVuZDogdW5kZWZpbmVkLFxuICAgICAgICBlcnJvcjogdW5kZWZpbmVkLFxuICAgICAgICBhYm9ydDogdW5kZWZpbmVkLFxuICAgICAgICBwaGFzZXM6IHtcbiAgICAgICAgICAgIHdhaXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGRuczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdGNwOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB0bHM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHJlcXVlc3Q6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGZpcnN0Qnl0ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZG93bmxvYWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHRvdGFsOiB1bmRlZmluZWRcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmVxdWVzdC50aW1pbmdzID0gdGltaW5ncztcbiAgICBjb25zdCBoYW5kbGVFcnJvciA9IChvcmlnaW4pID0+IHtcbiAgICAgICAgY29uc3QgZW1pdCA9IG9yaWdpbi5lbWl0LmJpbmQob3JpZ2luKTtcbiAgICAgICAgb3JpZ2luLmVtaXQgPSAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIC8vIENhdGNoZXMgdGhlIGBlcnJvcmAgZXZlbnRcbiAgICAgICAgICAgIGlmIChldmVudCA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgICAgIHRpbWluZ3MuZXJyb3IgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIHRpbWluZ3MucGhhc2VzLnRvdGFsID0gdGltaW5ncy5lcnJvciAtIHRpbWluZ3Muc3RhcnQ7XG4gICAgICAgICAgICAgICAgb3JpZ2luLmVtaXQgPSBlbWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2F2ZXMgdGhlIG9yaWdpbmFsIGJlaGF2aW9yXG4gICAgICAgICAgICByZXR1cm4gZW1pdChldmVudCwgLi4uYXJncyk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBoYW5kbGVFcnJvcihyZXF1ZXN0KTtcbiAgICBjb25zdCBvbkFib3J0ID0gKCkgPT4ge1xuICAgICAgICB0aW1pbmdzLmFib3J0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgLy8gTGV0IHRoZSBgZW5kYCByZXNwb25zZSBldmVudCBiZSByZXNwb25zaWJsZSBmb3Igc2V0dGluZyB0aGUgdG90YWwgcGhhc2UsXG4gICAgICAgIC8vIHVubGVzcyB0aGUgTm9kZS5qcyBtYWpvciB2ZXJzaW9uIGlzID49IDEzLlxuICAgICAgICBpZiAoIXRpbWluZ3MucmVzcG9uc2UgfHwgbm9kZWpzTWFqb3JWZXJzaW9uID49IDEzKSB7XG4gICAgICAgICAgICB0aW1pbmdzLnBoYXNlcy50b3RhbCA9IERhdGUubm93KCkgLSB0aW1pbmdzLnN0YXJ0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXF1ZXN0LnByZXBlbmRPbmNlTGlzdGVuZXIoJ2Fib3J0Jywgb25BYm9ydCk7XG4gICAgY29uc3Qgb25Tb2NrZXQgPSAoc29ja2V0KSA9PiB7XG4gICAgICAgIHRpbWluZ3Muc29ja2V0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGltaW5ncy5waGFzZXMud2FpdCA9IHRpbWluZ3Muc29ja2V0IC0gdGltaW5ncy5zdGFydDtcbiAgICAgICAgaWYgKHV0aWxfMS50eXBlcy5pc1Byb3h5KHNvY2tldCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsb29rdXBMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgICAgIHRpbWluZ3MubG9va3VwID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHRpbWluZ3MucGhhc2VzLmRucyA9IHRpbWluZ3MubG9va3VwIC0gdGltaW5ncy5zb2NrZXQ7XG4gICAgICAgIH07XG4gICAgICAgIHNvY2tldC5wcmVwZW5kT25jZUxpc3RlbmVyKCdsb29rdXAnLCBsb29rdXBMaXN0ZW5lcik7XG4gICAgICAgIGRlZmVyX3RvX2Nvbm5lY3RfMS5kZWZhdWx0KHNvY2tldCwge1xuICAgICAgICAgICAgY29ubmVjdDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRpbWluZ3MuY29ubmVjdCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWluZ3MubG9va3VwID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdsb29rdXAnLCBsb29rdXBMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIHRpbWluZ3MubG9va3VwID0gdGltaW5ncy5jb25uZWN0O1xuICAgICAgICAgICAgICAgICAgICB0aW1pbmdzLnBoYXNlcy5kbnMgPSB0aW1pbmdzLmxvb2t1cCAtIHRpbWluZ3Muc29ja2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aW1pbmdzLnBoYXNlcy50Y3AgPSB0aW1pbmdzLmNvbm5lY3QgLSB0aW1pbmdzLmxvb2t1cDtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNhbGxiYWNrIGlzIGNhbGxlZCBiZWZvcmUgZmx1c2hpbmcgYW55IGRhdGEsXG4gICAgICAgICAgICAgICAgLy8gc28gd2UgZG9uJ3QgbmVlZCB0byBzZXQgYHRpbWluZ3MucGhhc2VzLnJlcXVlc3RgIGhlcmUuXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VjdXJlQ29ubmVjdDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRpbWluZ3Muc2VjdXJlQ29ubmVjdCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgdGltaW5ncy5waGFzZXMudGxzID0gdGltaW5ncy5zZWN1cmVDb25uZWN0IC0gdGltaW5ncy5jb25uZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGlmIChyZXF1ZXN0LnNvY2tldCkge1xuICAgICAgICBvblNvY2tldChyZXF1ZXN0LnNvY2tldCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXF1ZXN0LnByZXBlbmRPbmNlTGlzdGVuZXIoJ3NvY2tldCcsIG9uU29ja2V0KTtcbiAgICB9XG4gICAgY29uc3Qgb25VcGxvYWQgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGltaW5ncy51cGxvYWQgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aW1pbmdzLnBoYXNlcy5yZXF1ZXN0ID0gdGltaW5ncy51cGxvYWQgLSAoKF9hID0gdGltaW5ncy5zZWN1cmVDb25uZWN0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aW1pbmdzLmNvbm5lY3QpO1xuICAgIH07XG4gICAgY29uc3Qgd3JpdGFibGVGaW5pc2hlZCA9ICgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0LndyaXRhYmxlRmluaXNoZWQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3Qud3JpdGFibGVGaW5pc2hlZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb2RlLmpzIGRvZXNuJ3QgaGF2ZSBgcmVxdWVzdC53cml0YWJsZUZpbmlzaGVkYCBwcm9wZXJ0eVxuICAgICAgICByZXR1cm4gcmVxdWVzdC5maW5pc2hlZCAmJiByZXF1ZXN0Lm91dHB1dFNpemUgPT09IDAgJiYgKCFyZXF1ZXN0LnNvY2tldCB8fCByZXF1ZXN0LnNvY2tldC53cml0YWJsZUxlbmd0aCA9PT0gMCk7XG4gICAgfTtcbiAgICBpZiAod3JpdGFibGVGaW5pc2hlZCgpKSB7XG4gICAgICAgIG9uVXBsb2FkKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXF1ZXN0LnByZXBlbmRPbmNlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uVXBsb2FkKTtcbiAgICB9XG4gICAgcmVxdWVzdC5wcmVwZW5kT25jZUxpc3RlbmVyKCdyZXNwb25zZScsIChyZXNwb25zZSkgPT4ge1xuICAgICAgICB0aW1pbmdzLnJlc3BvbnNlID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGltaW5ncy5waGFzZXMuZmlyc3RCeXRlID0gdGltaW5ncy5yZXNwb25zZSAtIHRpbWluZ3MudXBsb2FkO1xuICAgICAgICByZXNwb25zZS50aW1pbmdzID0gdGltaW5ncztcbiAgICAgICAgaGFuZGxlRXJyb3IocmVzcG9uc2UpO1xuICAgICAgICByZXNwb25zZS5wcmVwZW5kT25jZUxpc3RlbmVyKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aW1pbmdzLmVuZCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICB0aW1pbmdzLnBoYXNlcy5kb3dubG9hZCA9IHRpbWluZ3MuZW5kIC0gdGltaW5ncy5yZXNwb25zZTtcbiAgICAgICAgICAgIHRpbWluZ3MucGhhc2VzLnRvdGFsID0gdGltaW5ncy5lbmQgLSB0aW1pbmdzLnN0YXJ0O1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzcG9uc2UucHJlcGVuZE9uY2VMaXN0ZW5lcignYWJvcnRlZCcsIG9uQWJvcnQpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aW1pbmdzO1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IHRpbWVyO1xuLy8gRm9yIENvbW1vbkpTIGRlZmF1bHQgZXhwb3J0IHN1cHBvcnRcbm1vZHVsZS5leHBvcnRzID0gdGltZXI7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gdGltZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@szmarczak/http-timer/dist/source/index.js\n");

/***/ })

};
;